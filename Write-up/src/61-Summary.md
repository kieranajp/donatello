##Reflection on the Project
###Reflection on Omissions
The project, as detailed above, was a success. While it is disappointing that some of the nice-to-have features didn't manage to make it in, all the essential functionality is there and is working. The most major omissions are in the web service, due to the failing hard drive, but it is doubtful that anything different could have been done. While it is a situation that was foreseen as a potential risk (see [Appendix C](#Appendices-2-3)), the disk failed without warning, and turnaround on replacement and getting back to work was as quick as humanly possible. It is unfortunate that the disk failed at that exact time, but it seems doubtful that the situation could have been handled any differently without any foresight of its failure.

###Reflection on the SDLC and Planning
The SDLC that was used, hybridised waterfall and Scrum, worked surprisingly well considering it is a bespoke SDLC and not one widely recognised. The combination of the rigid, linear, one-thing-at-a-time waterfall methodology for the overall development process and the agile, feature-driven nature of Scrum for the actual coding turned out to compliment each other very well, and provide a very good compromise between the two lifecycles. This SDLC has been very effective, far more so than the originally-proposed Rapid Application Development (RAD), and is definitely recommended at the very least to try.

The planning for this project on the other hand was not always so flawless. While in tasks such as risk management and database design it was fine, an extreme oversight was made in one section. The client, .NET application was planned out very well, with class diagrams and thoughts as to user interface design, and cannot really be faulted. However, more attention could have been paid to planning the web service. While admittedly the less interesting of the two sections of the project, and probably the less important to the project's objectives and requirements as well, no real plan was made of the methods to be created and what they would output, or even the HTTP verbs they would accept (i.e. GET, POST, PUT and so on). The web service turned out to be successful in the sense that it met all the important requirements, but it must be admitted that it would have been a far greater success had more thought been put into its structure before developing it, and that it is the part of the project that is failing to meet those Could-Have requirements.

###Reflection on the Code
The overall quality of the code in the project is pretty good. It is not adhering to any particular design patterns such as MVP, but it is neat, fast, multithreaded and effective in what it does. The learning process in the multithreading was definitely a good experience, and the refactoring in particular was effective in greatly increasing the quality and the speed of the code. Following this process of refactoring, almost rewriting even, code after feature completion has become a habit, and is strongly recommended to help get rid of any messy code as a result of debugging and to increase developer pride in the finished product. The idea comes from Test-Driven Development's Red-Green-Refactor methodology, and despite not being applied to a test-first approach was such a boon to the project towards its completion. 

Some bits of code that are not so pride-inducing, however, are in the PHP of the web service. PHP is a fundamentally messy language - dynamically typed languages such as it or JavaScript often can be by many opinions - and as such sometimes it is hard to write 'neat' code in these languages (in stark contrast with the C# .NET of the client program). Something that the developer of this project lacks experience in is, not PHP itself, but in creating tidier, more object-oriented PHP, in particular PHP based around a framework such as CakePHP or CodeIgniter. These frameworks claim to help in structuring PHP - CodeIgniter in particular is a MVC framework, so should be particularly well-structured - and perhaps would have been a good choice for writing the web service. However using them at the time seemed like overkill - the web service uses a fairly small amount of code and a framework would have probably just served to bloat it. Perhaps using a different language would have helped somewhat - Ruby on Rails was an option mentioned during the planning phase, and Rails itself being an MVC framework could perhaps have led to neater code and more developer pride. PHP was a fine choice for this project, though, and the reasons for choosing it were sound. The web service functions fine, but it would be nice if the code were a little more tidy and well-formed.

##Future Work 
When carrying on with this project, the first work that would be done would be tidying up the code of the web service in the same vein as the C# code was thoroughly refactored after development. More API commands would also be added, and all the Could-Haves would obviously aim to be met. Additionally, given a server that allowed for SFTP transfers or other encryption methods, the transfer system would definitely be migrated to use that right away. This restriction made the project less realistic by many times, and coming to the realisation that this could not be implemented was disappointing.

Given funding and development resources, this application would certainly make a very desirable feature in other existing digital download services (such as Netflix, LoveFilm or Steam). The concept of being able to purchase items from one place and have them waiting for you upon arrival at another is undeniably convenient, and if this feature were implemented in a service one could foresee it being a fantastic selling point. In future this would be a great project, if the resources became hypothetically available.

##Conclusion
To summarise, then, the project can be considered a success due to the objectives outlined at the outset being met. The hybrid software development methodology used was in particular highly successful, and this coupled with risk management strategies helped to plan for the crisis that occurred in the form of the failed hard disk. The research performed and evaluated was incredibly useful in facilitating understanding of those strategies and methodologies, and only serves to support the perceived values of performing this preliminary work before commencing programming.

While some requirements ended up not being met (and as outlined multiple times, these were the non-essential requirements), the failures were due not to inaccuracies in the project's scope but to the aforementioned data loss crisis, and could not have been averted without future knowledge. The change in direction from the proposed website creation to creating an API was somewhat drastic but turned out to be a great move to add some uniqueness and further challenge to the project, and was thoroughly enjoyable to code. One can only hope that this sort of open system becomes more prevalent in future, as having APIs to plug into is incredibly useful for developers and spawns all sorts of innovation. One more thought: although this project was created to facilitate remote media downloads, the potential of this technology is staggering. With the correct listener applications running, remote commands could be sent to home PCs to perform many small tasks. The potential application in home automation alone, for example, is huge. Being able to send a command to a PC from anywhere could save many people a huge amount of time, and could easily become commonplace as the internet matures and technologies such as 3G / 4G networks become more widespread and computers shrink down to fit in pockets. Who knows what tasks could be accomplished with methods like this in the next few years.