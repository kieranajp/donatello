##Review of Research and Development methods
###Development Methodologies
During the development phase of the project, the design decisions and the plans drawn up will be used to produce an actual working artefact. However, it is always a good idea to, before diving into coding a program, work out a methodology to help the project's structure and to help control the creation process, from gathering of requirements right through to the final QA phase of development before project completion. This structure can be the difference between a project's success or failure, primarily by improving a team's productivity and focus - since everybody is working in the same method, and following the same contingency plans - and as such there are many methodologies to choose from, each with their own characteristics. No one methodology can therefore be applied to a particular project, particularly when projects' scales and goals can be so different. While development methodologies were first created for working with large-scale projects, as more and more come into existence, and as older, robust methodologies are adapted, they can often work with small, or in this case one-man projects as well to an extent, perhaps with some adaptation.

####Pure Waterfall
The waterfall methodology was developed in 1970 as a sequential process to follow throughout the development process. It consists of several clearly-defined phases, each of which must be completed before the next can start. These are:

1.	Requirements Specification
2.	Design
3.	Construction (i.e. implementation)
4.	Integration
5.	Testing and debugging
6.	Installation
7.	Maintenance

The waterfall model was used as a base in developing the structure of other methodologies, particularly those that also permit a similar sequential flow of phases. The rigid structure of the waterfall is useful for producing a product of high quality, as each phase of development must be entirely complete and without problems before moving onto the next phase. It also works well when the development team are technically weak, allowing them to concentrate on one thing at a time, and the structure lends itself well when the team is spread overseas - although not relevant in this instance. However, this rigid progression has some shortfalls also, most obviously in its inflexibility if the requirements change. In fact, seeing as the requirements must be set in stone before even moving forward on to the next step, they must all be defined at the outset. This can often be difficult, to say the least - requirements often change as work progresses and more information on its scope becomes apparent. Additionally, as the integration and testing phases are towards the end of the lifecycle, often it's not possible to 'see' the program in action until then. It's possible that, by this point, any changes a customer desires are impossible, or at the least extremely costly, to commit to. 

However, there are as previously mentioned many development methodologies, many of which are not as strictly iterative as 'pure' waterfall. Other Software Development Lifecycles (SDLCs) can take radically different approaches and thus can be extremely more adaptable for use projects where waterfall is simply unsuitable. The phases of these different lifecycles, while getting the same job done as in waterfall, can vary vastly in how much focus is put on them, the order in which they occur, and most importantly how they can be adapted as development goes on.

####Agile & Scrum
Agile methodology is becoming extremely popular in businesses worldwide. It is a model in which the end users and developers are in close and regular communication, making it very good for gathering and adapting to customer feedback. Because this rapport needs to be built up, it works best with small teams of developers. Testing is carried out throughout the development process, as opposed to in a lump after the main development has been completed. This testing can be split into two different kinds: user acceptance testing as well as unit testing for the developers' benefit. Various forms of and variations upon Agile development have been proposed, the emergent variant being Scrum methodology.

Scrum methodology involves assigning certain roles to individuals and splitting the workload in a certain way. One developer is assigned the title of the 'Scrum Master', who has the job of ensuring that the process is followed correctly, and a customer is assigned as the product owner, or primary stakeholder: the point of contact between the development team and the user base - the customers' spokesman. The work is split into 'sprints' - a unit of development with a specific objective, which should last a few weeks. Before each sprint, a meeting is held to determine what should be completed by its end. During a sprint, the requirements are not allowed to change, so if they have changed the issue must be raised in this meeting. Every day or few days during the sprint a short meeting, or scrum, is held, in which any customer is welcome, not just the product owner. During this, the development team members give progress updates on what they have achieved since the last scrum and what they intend to do next. After a sprint another meeting is held to review what was accomplished and demonstrate any new working features to the product owner.

Agile's incremental structure, alongside its provision for changes in requirements at certain points, is a very desirable thing to have. However, pulling this off requires very close monitoring by project managers and (if using Scrum) the Scrum Master, and often requires better quality developers than other, simpler methodologies. Given the correct resources, though, Agile is very usable in the real world, as evidenced by its widespread adoption.

####Making a Choice
Adopting a methodology for this project is no easy choice. While Agile is usually the better choice, in this case there is no customer - so some of the disadvantages of waterfall don't apply: for example, the requirements are likely to be set from the beginning with no chance of change, and having meetings becomes rather moot. Taking cues from various techniques seems to be the optimal approach. A rigid and iterative approach would be useful to help avoid trying to concentrate on too many things at once, however the idea of a sprint approach, with designated reflection periods upon completion of tasks, would be beneficial for refinement and refactoring not only of code but of the ideas and user experience concepts behind the artefact. As such, since neither approach as a whole is entirely appropriate to the project in question, a loose, one-person adaptation of some of the best features from both will be used in progressing this project.

###Project Management Methodologies
####PRINCE2
PRINCE, or PRojects IN Controlled Environments, is a structured approach to managing projects used in the UK, Western Europe and Australia. Originally evolved from PROMPT2 (Project Resource Organisation Management and PLanning Technique), a methodology developed in 1975, the first iteration of PRINCE was used from 1989. In this early stage it was only really suited to IT projects, and a revision in 1996 - PRINCE2 - widened its application for use in non-IT projects as well. The methodology was again revised in 1999 to make it smaller and more lightweight.

PRINCE2 is now the de-facto standard for project management in many countries - including being widely used by the UK government and in the private sector - for a few reasons. Firstly, it does not require any license to use, making it appealing solely based on not having to pay any licensing fees, and secondly because of the substantial benefits of using such a widely-recognised methodology so commonly-understood. PRINCE2 is a very comprehensive approach, and covers the management of many aspects of a project, including definitions of roles and tasks for key team members, guidelines for risk management and the actual provision of outlines for reports and documents. It also covers when such reports should be written, and outlines a procedure for product development from conception through to completion. However, because it is so comprehensive, PRINCE2 can be somewhat bureaucratic and full of red tape, and as such is best suited to larger projects.

####PMBOK
In contrast to the red tape of PRINCE2, PMBOK (the Project Management Book of Knowledge, the project management methodology prevalent in the United States) is more casual and more of a set of guidelines for managing projects rather than a structure to adhere to. First published as a white paper in 1987, and revised several times (the last major revision being in 2008), PMBOK's 'slogan', so to speak, is 'guidelines for managing most projects most of the time'. PMBOK is aware that it is not a one-size-fits-all solution and is thus more flexible and open to adaptation than the rigid PRINCE2. PMBOK's aim is to standardise project management techniques in five basic process groups: Initiation, Planning, Execution, Monitoring and Controlling, and Closure. It provides a best-fit approach to all of these areas, offering guidelines and over 40 processes that can be used or adapted for 'most' projects, and is designed to compliment other approaches to project work - for example the Capability Maturity Model (Integrated), or CMMI, a means of measuring the capability and maturity of a team to perform a specific task.

####Adapting a Methodology
Similar to with development techniques, unfortunately adapting a project management technique to cover a one-person outfit is not easy. While in a more traditional business project a methodology could be used, rigorously or otherwise, in this case the best approach is to simply take ideas and good practices from various sources and keep them in mind. Following a management technique strictly is next-to impossible - simply assigning the various outlined roles cannot be done without a workforce. However, using ideas from both PRINCE2 and PMBOK it is possible to come up with ideas of what needs to be considered when embarking on a project, of any scale, particularly during the planning stage. However, something that neither methodology covers in any great detail is risk management. This is something that will be important to cover in greater detail.

###Requirements Engineering
Requirements analysis and engineering can be critical to the success of a project. Being able to define the goals of a project, what it needs to fulfil, and being able to keep these in mind during the development process allows developers to focus on adhering to exactly what needs to be done during the creation process, ensuring that no essential features are missed out and that no time is wasted in designing and coding something that is not needed and perhaps not even wanted. The means in which requirements are gathered from an end-user base can vary greatly.

####Methods of Data Collection
All the many means of gathering data from users can fall under one of three categories: qualitative, quantitative and social. Quantitative data are data that can be expressed numerically, and as such is often shown in graphs and charts. The main method of collecting quantitative data is through questionnaires - the statistics retrieved through this means can be tallied up and put into visual formats. Qualitative data can be used to back this up: gathered via means such as direct observation or interviews, for example, it is possible to find out requirements in far more detail by using these methods, but it is far more time-consuming to accomplish. Finally, social data can be from a variety of sources - research findings, information from the media, or simply from use of logic. When beginning a project, depending on its scale and criticality, it may be desirable to use one or all of these sources to define its requirements.

####Volere
The Volere template is a requirements specification and analysis template available for commercial use. It was first drafted in 1995, and published in 1999, to provide a structure and common language to the process of gathering requirements from various sources. Volere consists of three interconnected components: the Requirements Knowledge Structure, which deals with how different requirements relate to each other; the Requirements Stakeholders, concerning the priority of the work and the appropriate level of detail in accordance with the stakeholders' needs; and the Requirements Process, or the procedures for discovering requirements. While a commercial product, and thus mainly reserved for use by businesses with the resources to justify the monetary cost (and has been used in thousands of projects across the globe by such customers), the creators of Volere, James and Suzanne Robinson, have made it available to students for free, making it well worth taking a look at even if it is more suited to larger products with vested stakeholders.

Volere encourages one to consider the purpose of a project, as well as the motivations for creating a product and the intended final users of it. While it is very easy to get caught up in certain development habits, different products often require wholly different approaches. By having this template to fill in when planning a project, the development team (or business analysts under certain cases) can focus much better on what is needed of them, and thus potentially produce a better product and increase customer satisfaction. Additionally, Volere asks questions that may not often be thought of, such as defining maintenance requirements and specifying naming conventions to use during development.

Being a modular process means that Volere is very flexible: it is possible to have a bespoke, 'bare-bones' version of the template which is simply used to gather the requirements of the project based on its budget, scope and time constraints, or the team can add more scope to the requirements gathering process. Volere is also designed to go hand-in-hand with processes such as use-case definitions, which will allow a greater extent of requirements to be defined based on the use-cases that have been envisioned.

####MoSCoW
The MoSCoW method is a prioritisation technique that comes into play during or after the gathering of requirements - meaning that the primary function of MoSCoW is not to be a means of gathering requirements, rather a means of defining their priorities in a very simple, self-explanatory and quick way. Developed as recently as 2004, MoSCoW is actually an acronym, standing for the four states of requirement (priorities) it encompasses. These are:  

*	Must Have
*	Should Have
*	Could Have
*	Won't Have

The simplicity and 'plain English' of these requirement prioritisations is incredibly useful when working with customers - simply handing a product owner a sheet containing these four headings and asking them to fill in their requirements is often viable, since the priorities' titles say everything necessary. *Must Have* defines the absolute necessities of the project - the outcomes that it must fulfil to be considered a success. If any of the Must requirements are not delivered, the project will have been a failure. *Should Have* requirements are critical to the project's success also, but are not essential to be included in the initial release. *Should* requirements often have workarounds, meaning that they can be semi-satisfied in some other way at least as a stopgap until their implementation.

The other two categories list requirements that are not essential for the deliverable to be considered 'complete'. *Could Have* requirements are 'nice-to-have'; things that would add to the value of a product and potentially the customer's satisfaction, but are only to be implemented if they are either judged simple enough to, or if there is time left over after the Must and Should Haves are finished. *Won't Have* requirements are those that the customer would like, but are the least critical items to be worked on. Sometimes referred to as *Would Haves*, these requirements are those that are not to be included in the current timescale of the project, but would definitely be up for contention in future revisions of the deliverable.

####Functional and Non-Functional Requirements
When gathering and prioritising requirements, no matter what method is used, it is useful to bear in mind that they fall into two distinct categories: functional and non-functional. To quote the Volere template, which is very clear on the definitions of the two:
> Functional requirements are the fundamental or essential subject matter of the product. They describe what the product has to do or what processing actions it must take.> > Non-functional requirements are the properties that the functions must have, such as performance and usability. Do not be deterred by the unfortunate name for this kind of requirements, they are as important as the functional requirements for the product’s success. 

Both types of requirement are essential to gather before beginning implementation, both types of requirement should be properly prioritised (using MoSCoW or otherwise), and both types of requirement count towards determining the level of success of a project upon its completion. In short, functional and non-functional requirements are equally important to the project's outcome.

####Evaluation of Methods
Gathering requirements for this project is going to be difficult without a customer or other user base to question. Observing and using applications that perform similar functions such as Steam or the iTunes Store will likely help in understanding what must be accomplished, and using some of the techniques outlined in Volere will be useful when considering, for example, the deployment requirements, or how use-cases and use-case diagrams (UCD's) can be used to add to the data already acquired. When it comes to prioritising the requirements once gathering is complete, MoSCoW is really the only suitable method. Many believe that other methods of requirements prioritisation are far inferior - its simplicity and comprehensiveness is a great combination, and other prioritisation techniques fall flat mostly by including numerical prioritisation rather than the far easier-to-understand worded method. Defining those Must/Should/Could requirements, however will likely be accomplished by observation of real-world applications and then prioritisation of their features. Obviously due to time and resource constraints the finished artefact will not have all the features of an application such as Steam, made over a period of years with the resources available to a company like Valve, and the Won't Have requirement category will likely be populated by very desirable features that must be dropped from this release of the application due to the constraints in time, budget and resources.

###Risk Management

###Testing Methods
Software testing is a means of ensuring that a software product works as intended for the targeted userbase and purposes. Bugs in code are inevitable, and even if every use case possible is tested it is likely some will remain; there are far too many variables to quash them all. However, without testing many bugs the software will probably not be user-friendly, with bugs, crashes and memory leaks all possible. Unless testing is carried out to find and fix these issues, a user's perception of software will generally be bad, since bugs ruin the user experience. 

Since testing is such an important part of the software life cycle, many methods of testing exist to make it as convenient to integrate into software development as thorough at discovering bugs and unwanted features as it can be. Besides simply going through a program and manipulating every control, comparing the result to what was expected (a technique known as black-box testing), there are other methods which test the internal workings of the code itself to ensure that, logically, everything is happening as it should - known as white-box testing. While black-box testing is performed on a finished software product, testing can be performed during development as well. For example, a technique known as unit testing is commonly used to test individual functions or classes to ensure they can handle all possible inputs, and will output the correct results. Unit testing involves writing additional code to serve as 'test cases', which *assert* that functions exist and that their output when given certain parameters is as expected - even if the expected result is an error.

While commonly tests are written once software has been created and run on the code that has been written, a technique known as regression testing, a method of software development - which actually in itself could be considered an iterative, Agile-based SDLC - known as Test-Driven Development (TDD) involves writing the unit tests first, before any code is written. TDD has become increasingly popular since its relatively recent invention in the early 2000s, and is used by large companies such as Microsoft and IBM. Its workflow, Red-Green-Refactor (Beck, K., 2003), is the best way to describe how it works.

1. Red: Write a test that describes how a code unit should work. It should FAIL when run, as the code it's attempting to test has not yet been written.
2. Green: Write code to make the test pass.
3. Refactor: When the test case passes, neaten up and reorganise the (potentially messy) code.
4. Repeat for another function

Test-Driven Development, then, changes the whole process of software testing to be proactive, rather than reacting to bugs. It can also serve as a means of defining low-level software requirements.